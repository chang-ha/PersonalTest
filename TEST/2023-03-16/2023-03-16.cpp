// 금일 강의 내용 : 레퍼런스(참조)

void TestPtr(int* Ptr)
{
	// 인자를 포인터 변수로 받음
}

void TestRef(int& Ref)
{
	// 인자를 레퍼런스 변수로 받음
}

// 함수의 인자가 *, &가 붙어있으면 함수를 통과하면 해당 인자는 값이 변경되어 나올 것이다.
// 안바꿀거면 const를 붙일 것이다. (안붙이면 실수)

void TestFunction(const int& _Ref)
{
	// 인자를 상수화된 레퍼런스 변수로 받음
	// _Ref = 10; << 오류발생 , const를 붙여서(상수화되서) 값을 바꿀수 없음.
	// const (int& or int*)가 붙어있으면 의도한 내용 (const가 붙어있으니까 이 함수를 써도 값이 안바뀐다는 것을 알려주는 것)
}


int main()
{
	
	int Value0 = 10;
	int Value1 = 20;

	// 래퍼런스란 대부분의 언어에서 참조라는 의미 = 특정 메모리영역의 위치를 가리킨다(쓰겠다).
	// 포인터도 참조형이라 부름
	
	// 포인터형 변수
	// 포인터는 언제든지 자신이 래퍼런스(참조, 가리킨다) 대상을 바꿀수 있다.
	int* Ptr = &Value0;
	Ptr = &Value1;


	// 레퍼런스(참조)형 변수
	// 레퍼런스는 초기화안하면 사용 불가능 = 무조건 누군가를 가리켜야함.
	// int& Ref; => 오류발생(초기화 안했기 때문)
	// 레퍼런스는 자신이 가리킨 대상을 바꿀수 없다.
	int& Ref = Value0;
	
	// 포인터는 주소값에 있는 값을 바꾸기 위해서는 아래처럼 해야함
	// *Ptr = 20;
	// 레퍼런스는 해당 문법이 기본으로 탑재(패시브)
	// 특정 이름의 변수가 있다고 쳤을 때
	// 이제부터 Value0이라는 얘를 이제부터 Ref라고도 부를께.
	// 모든 Ref는 Value0이라고 바꿔도 무방함

	// 한번 초기화시 참조한 메모리영역을 바꿀수가 없음!!!
	// Ref = Value1; << Value1을 가리키는게 아니라 Value1값을 Ref = Value0에 넣은 것
	// Ref는 한번 섬기는 주군(Valoue0)은 절대 배신하지 않는다.
	Ref = 20; // Ref = Value0 = 20으로 값이 바뀜

	// 기계어로 보면 포인터랑 레퍼런스랑 문법적으로 구분이 되어있을 뿐이지 완전이 동일
	// 둘의 차이가 있다면 포인터는 가리키는 대상을 바꿀수 있지만, 레퍼런스는 못바꿈
	// 문법상 포인터가 유용할 떄가 있고, 유용하지 않을 때가 있음(그래서 레퍼런스를 새로 만든듯????)




	TestPtr(nullptr); // << 비워둘 수 있음 ex : 장비칸
	// TestRef(); 이 함수는 절대로 값을 비워둘 수 없음 << 제작자의 의도에 따라 Ref를 쓰는게 유용(비워둘 수 없다)


	// sizeof해보면?
	// value0 = 4 , 앞에선 모든 포인터는 8byte라 했는데?? 확인해보면
	int value0 = sizeof(Ref); // Ref는 언제나 *이 붙은 포인터
	int value1 = sizeof(Ptr); // 모든 포인터는 8바이트
	int value2 = sizeof(*Ptr); // int는 4바이트니까 sizeof는 4바이트가 되는 것, 따라서 Ref = *Ptr이니까 sizeof하면 4바이트가 되는 것
	
}

