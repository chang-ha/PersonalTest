// 배열, printf, const, inline
#include <iostream>

int main()
{
    // 어떤 자료형을 봤다면 그것은 추가적인 문법으로 모두다 배열이 될 수 있습니다.
    // 배열은 선언했다면 모든 자료들이 딱 붙어있음
    // ex) int 배열이고 첫번째 값이 100번째면
    // 그 다음은 104, 108 ...
    // bool(1Byte)자료값이면 100, 101, 102...

    int Value = 10;

    // 배열은 자동으로 전부다 0으로 초기화 됩니다.
    int ArrValue[5] = {};

    {
        // 아래는 초기화 하지 않은 것 = 무슨 값이 들어갈지 모름
        int ArrValue[5]; 
        int a;
    }

    {
        // 아래는 배열 크기를 넘어감
        // int ArrValue[5] = { 0, 1, 2, 3, 4, 5 };
    }

    {
        // 넣은것 까지만, 나머지는 0
        int ArrValue[5] = { 2, };
        int a = 0;
    }

    {
        // false, false, false, false, false
        // c++에서는 숫자0을 false로 대신하는게 선호되지 않음
        // 정확하게 false, true로 표현하기 (숫자로 표현할 수 있지만 안하는거 권장)
        bool ArrValue[5] = {};
    }

    {
        bool ArrValue[5] = { false, true, true, true, true };
    }

    {
        int value1 = 10; // 이게 메모리상에서 100번째면 아래는 104번째일까??? X
        int value2 = 20; // 메모리 어디에 위치할 지 모름
    }

    // 문자의 배열은 축약형 표현을 사용할 수 있습니다.
    // 추가적인 규칙 => printf에서 설명
    {
        char ArrValue1[5] = { 'a', 'b', 'c' };
        // 위 선언은 아래로 표현할 수 있음
        char ArrValue2[5] = "abc";
    }

    // ---------------------------------------------------------------------------------
    // printf

    // 콘솔창에 글자를 띄우는 명령어
    // 일단 사용법만 강의;
    // ctrl + F5
    // printf_s("aaaaaa");


    // char arr[5] = "abc";
    // printf_s(arr);



    // 숫자 1과 문자'1'은 전혀 다른 내용
    {
        // 왜 아래 내용은 안되는 건가?? 5칸의 배열에 5개를 넣었는데??
        // char Arr[5] = "12345";
        char Arr[5] = { '1', '2', '3', '4', '5' };

        // 둘의 자료형이 다르기 때문에 오른쪽에서 왼쪽으로 들어가지 못함
        // char Value1 = Arr;
        // 제로베이스 기반.
        // 배열의 개수를 셀 때 0부터 세는것을 제로베이스 기반이라고함
        // [] << 랜덤 인덱스 연산자라고 부름
        // Arr[정수]; => Arr의 시작위치 + (sizeof(자료형) * 정수) 위치의 데이터에 접근한다는 뜻
        char Value1 = Arr[0];
        char Value2 = Arr[1];
        char Value3 = Arr[2];
        char Value4 = Arr[3];
        char Value5 = Arr[4];

        // 이를 출력하면 이상한 값들이 계속 나옴 = 메모리영역 뒤에 비트가 계속 이어지기 때문에 계속 출력하기 때문
        printf_s(Arr);

        // 따라서 규칙을 만듬
        // 제대로 된 글자 배열은 마지막에 무조건 숫자0을 넣기로 함
        // 그래서 아까 char Arr[5] = "12345"; 가 불가능 했던 것 (내생각 : 컴파일러가 제대로 된 글자 배열을 만들려고 {'1', '2', '3', '4', '5', 0}을 넣으려고 했지만 배열크기가 5라서 에러) 
        // "12345"를 넣으려면 배열 6칸이 필요한 것(마지막에 숫자0 이 필요하기 때문)
        // 따라서 char Arr[6] = "12345";로 수정하면 가능
        
        // char Arr[5] = {'1', '2', '3', '4', '5' }; 는 강제로 마지막 배열에 '5'를 넣은것

        // 문자열 상수 표현식을 사용하면 무조건 마지막에 컴파일러가 0을 붙임

        char ArrTest[10] = "abcdefghi";
        // g값을 가져오고 싶다면?
        char result = ArrTest[6];
    }


    // ---------------------------------------------------------------------------
    // const

    {
        // 함수의 스택에서의 메모리 크기는 컴파일시 고정되어야 하기 때문.
        // 배열의 크기는 선언해줘야함
        // c++의 함수의 실행흐름을 만들기 위한 스택크기는 .exe파일에 이미 다 정의되어 있어야 한다.
        int Value[10] = {};

        // 아래는 불가능
        // int ArrSize = 20;
        // int Value[ArrSize] = {};

        // 특정 자료형앞에 Const 키워드를 붙이면 <= Const는 어느 자료형이든 붙일 수 있다.
        // 그 메모리의 비트적 상수화를 시킨다. <= 비트 하나도 바꿀수 없음
        const int Arrsize = 20;

        // Arrsize = 30; << 불가능 = 비트적 상수화를 시켰기 때문
        int Value2[Arrsize] = {};


        // 아래 내용은 쓸모없는 코드 << 컴파일러가 무시함(F9걸어도 무시함) << 컴파일러 최적화라고함
        "Testchar"; // << consst char[9] = 바꿀수 없는 상수라는 뜻


    }

    // ---------------------------------------------------------------------------
    // inline
    // inline은 함수에 붙일 수 있다.
    // inline은 최적화 할 수 있으면 해달라는뜻 = 내부 내용을 복사해서 메인에 붙여넣는 느낌
    // 컴파일러 판단에 따라 inline 불가능 할 수도 있음.
    // 함수를 만들면 스택을 더 만들고 메모리를 차지 하기 때문에 일을 더 하는 것을 방지 (그냥 조금이라도 빠르게 하려고, 가능하면 해줘 ^^)
    // 항상 빨라지지는 않지만 대부분 빨라짐, 대부분 붙이는게 좋음


    Test();
}

inline void Test()
{
    printf_s("Function");
}