// 058_inheritanceMemory


#include <iostream>
class A
{
public:
	__int64 Test;
	// 생성자
	A()
		: Test(10)
		// 초기화 == 메모리가 만들어지는 순간 값을 입력
		// 맴버이니셜라이저의 문법의 의미
		// 멤버변수의 메모리 생성을 여기서 하는 거예요.
	{
		printf_s("A생성자\n");
	}

	// 소멸자
	// ~클래스 이름
	// 이름은 고정(생성자와 마찬가지)
	// 일반함수처럼 호출할 수 있지만 메모리가 파괴되지는 않는다
	// 소멸자는 인자를 넣어줄수 없다.
	~A()
	{
		Test = 40;
		printf_s("A의 소멸자\n");
	}
};
class B : public A
{
public:
	char Value;
	B()
	{
		// 만들어지고 나서는 이용밖에 못함(대입)
		Test = 30;
		printf_s("B생성자\n");
	}

	// 소멸자
	~B()
	{
		// 자식이 먼저 파괴됨
		// 부모가 먼저 파괴되면 Test를 사용 불가능
		Test = 20;
		printf_s("B의 소멸자\n");
	}
};

int main()
{
	// 부모가 먼저 호출됨
	// 왜 부모가 먼저 호출되냐?? 자식이 써야하니까
	B Test = B();

	// 클래스 A를 그냥 복붙한거랑 똑같음
	int Value = sizeof(B);

	// 호출할수있지만 상식을 벗어난 행위로 본다.
	// 절대 직접호출하지 말자
	Test.~B();
	int a = 0;


} // <= 실행흐름의 끝에서 함수의 메모리가 전부 정리됨
// 이때 호출되는 함수가 있음(소멸자)


// 남은 문법
// 나머지 클래스 디폴트(아무것도 안했는데 되는것들)
// 추살화 virtual
// 힙